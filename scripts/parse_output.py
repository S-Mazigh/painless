# This script was mainly generated by AI, it iterates in the metric dir in an output dir to generate a graph, and print the average time and par2
# It only checks the number of rows in the times.csv file to detect different experiments (better to be done by checking the instance column)


import os
import re
import pandas as pd
import sys

import matplotlib.pyplot as plt
import pandas as pd

def read_csv_files(root_dir):
    data = {}
    for directory in os.listdir(root_dir):
        directory_path = os.path.join(root_dir, directory)
        if os.path.isdir(directory_path):
            csv_files = [f for f in os.listdir(directory_path) if re.match(r'times_.*\.csv', f)]
            if csv_files:
                csv_file = os.path.join(directory_path, csv_files[0])
                # Read CSV file with index_col=False to ensure first column is not used as index
                df = pd.read_csv(csv_file, index_col=False)
                data[directory] = df
    return data


def check(data):
    row_counts = {directory: len(df) for directory, df in data.items()}
    first_directory = next(iter(data))
    first_row_count = row_counts[first_directory]
    for directory, row_count in row_counts.items():
        if row_count != first_row_count:
            print(f"Error: Number of rows in directory '{directory}' does not match the first directory '{first_directory}'.")
            return False
    print(f"All directories have the same number of rows as '{first_directory}'.")
    return True

def print_average_time_and_myPar2(data):
    for directory, df in data.items():
        print(f"Directory: {directory}")
        if 'time' in df.columns and 'myPar2' in df.columns:
            avg_time = df['time'].mean()
            avg_myPar2 = df['myPar2'].mean()
            print(f"Average time: {avg_time}")
            print(f"Average myPar2: {avg_myPar2}")
        else:
            print("Columns 'time' and/or 'myPar2' not found in DataFrame.")
        print()

def draw_graph(data):
    timeout = 5000  # Set timeout value
    plt.figure(dpi=300)
    
    markers = ['o', 'v', '^', 'd', 's', 'p', '*', 'h', 'H', '1', '2', '3', '<', '4', '>', '+', 'x', 'D', '|', '_', 'P', 'X', '8']
    marker_iter = iter(markers)
    
    for directory, df in data.items():
        # Sort by 'time' column in ascending order
        match = re.search(r'_L(\d+)_G(-?\d+).*?(\D*)$', directory)
        if match:
            L_value = match.group(1)
            G_value = match.group(2)
            if G_value == '-1':
                title_info = f"Painless_L{L_value}{match.group(3)}"
            else:
                title_info = f"Painless_L{L_value}_G{G_value}{match.group(3)}"
        else:
            title_info = directory
        
        # Sort by 'time' column in ascending order
        df.sort_values(by='time', inplace=True)
        # Reset row index
        df.reset_index(drop=True, inplace=True)
        
        # Replace values >= timeout with None
        df.loc[df['time'] >= timeout, 'time'] = None
        
        marker = next(marker_iter)
        plt.plot(df['time'], df.index, label=title_info, marker=marker, markersize=4, linestyle='-', markeredgewidth=0.25, markeredgecolor='white')

    # Draw red line at timeout
    plt.gca().spines['right'].set_color('red')

    plt.ylim(0, None)
    plt.xlim(0, timeout)
    plt.ylabel("Number of resolved instances")
    plt.xlabel("Execution Time (s)")
    plt.legend(title="Instances")
    plt.title("")
    plt.grid(True)
    plt.tight_layout()
    plt.show()


if __name__ == "__main__":
    if len(sys.argv) != 2:
        print("Usage: python3 myscript.py root_dir")
        exit(1)

    root_dir = sys.argv[1]

    if not os.path.isdir(root_dir):
        print("Error: Root directory does not exist.")
        exit(1)

    data = read_csv_files(root_dir)
    print("Data stored in dictionary:")
    for directory, df in data.items():
        print(f"Directory: {directory}")
        print(df)
        print()

    if check(data):
        print_average_time_and_myPar2(data)
        draw_graph(data)
    